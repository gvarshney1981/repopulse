import re
from typing import Dict, List, Tuple, Any
from dataclasses import dataclass
from datetime import datetime, date

@dataclass
class ConservativeAnalysisResult:
    """Result of conservative AI analysis"""
    is_ai: bool
    confidence: float
    strong_indicators: List[str]
    weak_indicators: List[str]
    reasoning: str

class ConservativeAIDetector:
    """Conservative AI detector that minimizes false positives"""
    
    def __init__(self):
        # Very specific AI patterns that are rarely found in human code
        self.strong_ai_patterns = {
            'explicit_ai_mention': [
                r'\b(generated by|ai generated|machine generated|auto generated|assisted by)\b',
                r'\b(cursor|copilot|ghostwriter|ai assistant|ai tool)\b',
                r'\b(chatgpt|gpt|claude|bard|perplexity)\b'
            ],
            'excessive_documentation': [
                r'///\s*<summary>.*?</summary>',  # XML documentation on every method
                r'///\s*<param.*?>.*?</param>',   # Parameter documentation
                r'///\s*<returns>.*?</returns>'   # Return documentation
            ],
            'over_engineering': [
                r'\b(IRepository<.*?>|IUnitOfWork|IService<.*?>)\b',  # Excessive interfaces
                r'\b(AddScoped|AddTransient|AddSingleton)\b.*\b(AddScoped|AddTransient|AddSingleton)\b',  # Multiple DI registrations
                r'\b(ValidationAttribute|IValidator|FluentValidation)\b'  # Excessive validation
            ],
            'perfect_formatting': [
                r'^\s{4}\w+\s+\w+\s*\([^)]*\)\s*\{$',  # Perfect method formatting
                r'^\s{4}\}\s*$',  # Perfect closing brace alignment
                r'^\s{8}\w+\s*=\s*\w+;?\s*$'  # Perfect variable assignment alignment
            ],
            'excessive_patterns': [
                r'\basync\s+\w+\s+\w+\s*\([^)]*\)\s*\{.*?\bawait\b.*?\}',  # Async/await everywhere
                r'\.Where\([^)]*\)\.Select\([^)]*\)\.ToList\(\)',  # Complex LINQ chains
                r'\bvar\s+\w+\s*=\s*new\s+\w+<[^>]+>\([^)]*\);'  # Generic instantiation
            ]
        }
        
        # Weak indicators that might suggest AI but are common in human code
        self.weak_ai_patterns = {
            'modern_csharp': [
                r'\basync\b', r'\bawait\b', r'\bvar\b',
                r'\.Where\(', r'\.Select\(', r'\.FirstOrDefault\(',
                r'AddScoped', r'AddTransient', r'AddSingleton'
            ],
            'good_practices': [
                r'\bpublic\s+\w+\s+\w+\s*\(',  # Public methods
                r'\bprivate\s+\w+\s+\w+\s*\(',  # Private methods
                r'\binterface\s+\w+',  # Interfaces
                r'\bclass\s+\w+',  # Classes
                r'///\s*',  # Comments
                r'\btry\s*\{',  # Error handling
                r'\bcatch\s*\('  # Error handling
            ],
            'common_keywords': [
                r'\bfix\b', r'\bupdate\b', r'\bimplement\b', r'\badd\b',
                r'\bmodify\b', r'\bchange\b', r'\bimprove\b', r'\benhance\b'
            ]
        }
    
    def analyze_commit(self, commit_message: str, commit_date: str, file_path: str, file_content: str = None) -> ConservativeAnalysisResult:
        """Analyze a commit for AI indicators using conservative approach"""
        
        strong_indicators = []
        weak_indicators = []
        reasoning = []
        
        # 1. Check for explicit AI mentions (strongest indicator)
        for pattern in self.strong_ai_patterns['explicit_ai_mention']:
            if re.search(pattern, commit_message, re.IGNORECASE):
                strong_indicators.append("explicit_ai_mention")
                reasoning.append(f"Commit message explicitly mentions AI: '{pattern}'")
        
        # 2. Analyze file content if available
        if file_content and file_path.lower().endswith('.cs'):
            file_analysis = self._analyze_file_content(file_content)
            strong_indicators.extend(file_analysis['strong'])
            weak_indicators.extend(file_analysis['weak'])
            reasoning.extend(file_analysis['reasoning'])
        
        # 3. Check commit message patterns
        message_analysis = self._analyze_commit_message(commit_message)
        strong_indicators.extend(message_analysis['strong'])
        weak_indicators.extend(message_analysis['weak'])
        reasoning.extend(message_analysis['reasoning'])
        
        # 4. Calculate confidence based on strong indicators only
        confidence = self._calculate_confidence(strong_indicators, weak_indicators)
        
        # 5. Very conservative threshold - only flag if multiple strong indicators
        is_ai = len(strong_indicators) >= 2 or (len(strong_indicators) >= 1 and confidence > 0.8)
        
        return ConservativeAnalysisResult(
            is_ai=is_ai,
            confidence=confidence,
            strong_indicators=strong_indicators,
            weak_indicators=weak_indicators,
            reasoning='; '.join(reasoning) if reasoning else "No strong AI indicators found"
        )
    
    def _analyze_file_content(self, content: str) -> Dict[str, List[str]]:
        """Analyze file content for AI indicators"""
        strong_indicators = []
        weak_indicators = []
        reasoning = []
        
        lines = content.split('\n')
        
        # Check for excessive documentation
        xml_doc_count = len(re.findall(r'///\s*<[^>]+>', content))
        method_count = len(re.findall(r'\b(public|private|protected|internal)\s+\w+\s+\w+\s*\(', content))
        
        if method_count > 0 and xml_doc_count / method_count > 0.9:  # Only if 90%+ methods documented
            strong_indicators.append("excessive_xml_documentation")
            reasoning.append(f"High XML documentation ratio: {xml_doc_count}/{method_count} methods documented")
        
        # Check for perfect formatting consistency (very high threshold)
        formatting_score = self._calculate_formatting_perfection(content)
        if formatting_score > 0.99 and len(lines) > 20:  # Only flag if 99%+ perfect AND substantial code
            strong_indicators.append("perfect_formatting")
            reasoning.append(f"Near-perfect formatting consistency: {formatting_score:.2f}")
        
        # Check for over-engineering patterns
        over_engineering_score = self._calculate_over_engineering(content)
        if over_engineering_score > 0.7:
            strong_indicators.append("over_engineering")
            reasoning.append(f"High over-engineering score: {over_engineering_score:.2f}")
        
        # Check for excessive async usage
        async_methods = len(re.findall(r'\basync\s+\w+\s+\w+\s*\(', content))
        total_methods = len(re.findall(r'\b(public|private|protected|internal)\s+\w+\s+\w+\s*\(', content))
        
        if total_methods > 0 and async_methods / total_methods > 0.8:
            strong_indicators.append("excessive_async_usage")
            reasoning.append(f"High async method ratio: {async_methods}/{total_methods}")
        
        # Check for complex LINQ chains
        complex_linq_chains = len(re.findall(r'\.Where\([^)]*\)\.Select\([^)]*\)\.ToList\(\)', content))
        if complex_linq_chains > 3:
            strong_indicators.append("complex_linq_chains")
            reasoning.append(f"Multiple complex LINQ chains: {complex_linq_chains}")
        
        # Check for excessive dependency injection
        di_registrations = len(re.findall(r'(AddScoped|AddTransient|AddSingleton)', content))
        if di_registrations > 10:
            strong_indicators.append("excessive_di_registration")
            reasoning.append(f"Many DI registrations: {di_registrations}")
        
        # Weak indicators
        if len(re.findall(r'\basync\b', content)) > 0:
            weak_indicators.append("async_usage")
        
        if len(re.findall(r'\.Where\(', content)) > 0:
            weak_indicators.append("linq_usage")
        
        if len(re.findall(r'AddScoped|AddTransient|AddSingleton', content)) > 0:
            weak_indicators.append("dependency_injection")
        
        return {
            'strong': strong_indicators,
            'weak': weak_indicators,
            'reasoning': reasoning
        }
    
    def _analyze_commit_message(self, message: str) -> Dict[str, List[str]]:
        """Analyze commit message for AI indicators"""
        strong_indicators = []
        weak_indicators = []
        reasoning = []
        
        message_lower = message.lower()
        
        # Check for explicit AI mentions
        explicit_ai_words = ['cursor', 'copilot', 'ai', 'generated', 'assistant']
        for word in explicit_ai_words:
            if word in message_lower:
                strong_indicators.append(f"explicit_ai_word: {word}")
                reasoning.append(f"Commit message contains AI-related word: '{word}'")
        
        # Check for overly descriptive commit messages (AI tends to be very descriptive)
        if len(message.split()) > 20:
            strong_indicators.append("overly_descriptive_message")
            reasoning.append(f"Very long commit message: {len(message.split())} words")
        
        # Check for perfect grammar and formatting in commit message (only if very obvious)
        if self._is_perfectly_formatted_message(message) and len(message.split()) > 15:
            strong_indicators.append("perfect_message_formatting")
            reasoning.append("Commit message has perfect formatting and grammar")
        
        # Weak indicators
        common_words = ['fix', 'update', 'implement', 'add', 'modify', 'improve']
        for word in common_words:
            if word in message_lower:
                weak_indicators.append(f"common_word: {word}")
        
        return {
            'strong': strong_indicators,
            'weak': weak_indicators,
            'reasoning': reasoning
        }
    
    def _calculate_formatting_perfection(self, content: str) -> float:
        """Calculate how perfectly formatted the code is"""
        lines = content.split('\n')
        if not lines:
            return 0.0
        
        perfect_lines = 0
        total_lines = 0
        
        for line in lines:
            if line.strip():
                total_lines += 1
                
                # Check for perfect indentation (multiples of 4)
                indent = len(line) - len(line.lstrip())
                if indent % 4 == 0:
                    perfect_lines += 1
                
                # Check for consistent spacing around operators
                if re.match(r'^\s*\w+\s*=\s*\w+;?\s*$', line):
                    perfect_lines += 1
                
                # Check for consistent method formatting
                if re.match(r'^\s{4}\w+\s+\w+\s*\([^)]*\)\s*\{?\s*$', line):
                    perfect_lines += 1
        
        perfection_ratio = perfect_lines / max(total_lines, 1)
        
        # Only consider it "perfect" if >95% of lines are perfectly formatted
        # AND we have enough lines to make this meaningful
        if total_lines < 10:
            return 0.0  # Not enough lines to judge
        
        return perfection_ratio
    
    def _calculate_over_engineering(self, content: str) -> float:
        """Calculate over-engineering score"""
        score = 0.0
        
        # Interface to implementation ratio
        interfaces = len(re.findall(r'\binterface\s+\w+', content))
        classes = len(re.findall(r'\bclass\s+\w+', content))
        
        if classes > 0:
            interface_ratio = interfaces / classes
            score += min(interface_ratio * 0.3, 0.3)  # Max 30% for interface ratio
        
        # Dependency injection usage
        di_usage = len(re.findall(r'(AddScoped|AddTransient|AddSingleton)', content))
        score += min(di_usage * 0.05, 0.2)  # Max 20% for DI usage
        
        # Validation attributes
        validation_attrs = len(re.findall(r'\[(Required|StringLength|Range|EmailAddress|Phone|Url)\]', content))
        score += min(validation_attrs * 0.02, 0.2)  # Max 20% for validation
        
        # Repository pattern usage
        repo_patterns = len(re.findall(r'(IRepository|Repository|IUnitOfWork)', content))
        score += min(repo_patterns * 0.1, 0.3)  # Max 30% for repository patterns
        
        return min(score, 1.0)
    
    def _is_perfectly_formatted_message(self, message: str) -> bool:
        """Check if commit message has perfect formatting"""
        # Check for proper capitalization
        sentences = message.split('. ')
        if len(sentences) > 1:
            for sentence in sentences[:-1]:  # All but last sentence
                if sentence and not sentence[0].isupper():
                    return False
        
        # Check for consistent punctuation
        if message.count('.') > 0 and not message.endswith('.'):
            return False
        
        # Check for no extra spaces
        if '  ' in message:
            return False
        
        return True
    
    def _calculate_confidence(self, strong_indicators: List[str], weak_indicators: List[str]) -> float:
        """Calculate confidence based on indicators"""
        base_confidence = 0.0
        
        # Strong indicators have high weight
        for indicator in strong_indicators:
            if 'explicit_ai' in indicator:
                base_confidence += 0.4
            elif 'excessive' in indicator:
                base_confidence += 0.3
            elif 'perfect' in indicator:
                base_confidence += 0.2
            else:
                base_confidence += 0.15
        
        # Weak indicators have low weight
        for indicator in weak_indicators:
            base_confidence += 0.05
        
        # Cap at 1.0
        return min(base_confidence, 1.0)

# Usage example
def detect_ai_conservative(commit_message: str, commit_date: str, file_path: str, file_content: str = None) -> Tuple[bool, float, str]:
    """Conservative AI detection function"""
    detector = ConservativeAIDetector()
    result = detector.analyze_commit(commit_message, commit_date, file_path, file_content)
    
    return result.is_ai, result.confidence, result.reasoning 