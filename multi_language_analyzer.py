import re
from typing import Dict, List, Tuple, Any
from dataclasses import dataclass
from datetime import datetime, date

@dataclass
class MultiLanguageAnalysisResult:
    """Result of multi-language AI analysis"""
    is_ai: bool
    confidence: float
    strong_indicators: List[str]
    weak_indicators: List[str]
    reasoning: str
    language: str

class MultiLanguageAIDetector:
    """Multi-language AI detector for C#, JavaScript, and React"""
    
    def __init__(self):
        # Language-specific file extensions
        self.language_extensions = {
            'csharp': ['.cs'],
            'javascript': ['.js', '.jsx'],
            'typescript': ['.ts', '.tsx']
        }
        
        # Common AI patterns across all languages
        self.common_ai_patterns = {
            'explicit_ai_mention': [
                r'\b(generated by|ai generated|machine generated|auto generated|assisted by)\b',
                r'\b(cursor|copilot|ghostwriter|ai assistant|ai tool)\b',
                r'\b(chatgpt|gpt|claude|bard|perplexity)\b'
            ],
            'excessive_documentation': [
                r'///\s*<[^>]+>',  # XML documentation
                r'/\*\*[\s\S]*?\*/',  # JSDoc comments
                r'//\s*@[a-zA-Z]+\s+',  # JSDoc annotations
            ],
            'perfect_formatting': [
                r'^\s{4}\w+\s+\w+\s*\([^)]*\)\s*\{$',  # Perfect method formatting
                r'^\s{4}\}\s*$',  # Perfect closing brace alignment
                r'^\s{8}\w+\s*=\s*\w+;?\s*$'  # Perfect variable assignment alignment
            ]
        }
        
        # C# specific patterns
        self.csharp_patterns = {
            'async_await': [
                r'\basync\s+\w+\s+\w+\s*\([^)]*\)\s*\{.*?\bawait\b.*?\}',
                r'\bTask<.*?>\s+\w+\s*\([^)]*\)'
            ],
            'linq_usage': [
                r'\.Where\([^)]*\)\.Select\([^)]*\)\.ToList\(\)',
                r'\.FirstOrDefault\([^)]*\)',
                r'\.Any\([^)]*\)'
            ],
            'dependency_injection': [
                r'(IServiceCollection|AddScoped|AddTransient|AddSingleton)',
                r'\bIRepository<.*?>',
                r'\bIUnitOfWork\b'
            ],
            'validation': [
                r'\[(Required|StringLength|Range|EmailAddress|Phone|Url)\]',
                r'\bValidationAttribute\b',
                r'\bIValidator\b'
            ],
            'over_engineering': [
                r'\binterface\s+\w+<.*?>',
                r'\babstract\s+class\s+\w+',
                r'\bsealed\s+class\s+\w+'
            ]
        }
        
        # JavaScript/React specific patterns
        self.javascript_patterns = {
            'react_hooks': [
                r'\buseState\s*\([^)]*\)',
                r'\buseEffect\s*\([^)]*\)',
                r'\buseCallback\s*\([^)]*\)',
                r'\buseMemo\s*\([^)]*\)',
                r'\buseRef\s*\([^)]*\)'
            ],
            'modern_js': [
                r'const\s+\w+\s*=\s*\([^)]*\)\s*=>\s*\{',
                r'const\s+\{\s*\w+\s*\}\s*=\s*\w+',
                r'\.map\s*\([^)]*\)\.filter\s*\([^)]*\)',
                r'\.then\s*\([^)]*\)\.catch\s*\([^)]*\)'
            ],
            'excessive_jsdoc': [
                r'/\*\*[\s\S]*?@param[\s\S]*?@returns[\s\S]*?\*/',
                r'//\s*@param\s+\{[^}]*\}\s+\w+',
                r'//\s*@returns\s+\{[^}]*\}'
            ],
            'over_engineering_js': [
                r'class\s+\w+\s+extends\s+React\.Component',
                r'const\s+\w+\s*=\s*React\.memo\s*\(',
                r'const\s+\w+\s*=\s*forwardRef\s*\('
            ]
        }
    
    def detect_language(self, file_path: str) -> str:
        """Detect the programming language based on file extension"""
        if not file_path:
            return 'unknown'
        
        file_lower = file_path.lower()
        
        for lang, extensions in self.language_extensions.items():
            if any(file_lower.endswith(ext) for ext in extensions):
                return lang
        
        return 'unknown'
    
    def analyze_file(self, commit_message: str, commit_date: str, file_path: str, file_content: str = None) -> MultiLanguageAnalysisResult:
        """Analyze a file for AI indicators based on its language"""
        
        language = self.detect_language(file_path)
        
        if language == 'csharp':
            return self._analyze_csharp_file(commit_message, commit_date, file_path, file_content)
        elif language in ['javascript', 'typescript']:
            return self._analyze_javascript_file(commit_message, commit_date, file_path, file_content)
        else:
            # Fallback for unknown languages
            return self._analyze_generic_file(commit_message, commit_date, file_path, file_content)
    
    def _analyze_csharp_file(self, commit_message: str, commit_date: str, file_path: str, file_content: str = None) -> MultiLanguageAnalysisResult:
        """Analyze C# file for AI indicators"""
        
        strong_indicators = []
        weak_indicators = []
        reasoning = []
        
        # 1. Check for explicit AI mentions
        for pattern in self.common_ai_patterns['explicit_ai_mention']:
            if re.search(pattern, commit_message, re.IGNORECASE):
                strong_indicators.append("explicit_ai_mention")
                reasoning.append(f"Commit message explicitly mentions AI: '{pattern}'")
        
        # 2. Analyze file content if available
        if file_content:
            content_analysis = self._analyze_csharp_content(file_content)
            strong_indicators.extend(content_analysis['strong'])
            weak_indicators.extend(content_analysis['weak'])
            reasoning.extend(content_analysis['reasoning'])
        
        # 3. Check commit message patterns
        message_analysis = self._analyze_commit_message(commit_message)
        strong_indicators.extend(message_analysis['strong'])
        weak_indicators.extend(message_analysis['weak'])
        reasoning.extend(message_analysis['reasoning'])
        
        # 4. Calculate confidence
        confidence = self._calculate_confidence(strong_indicators, weak_indicators)
        
        # 5. Conservative threshold
        is_ai = len(strong_indicators) >= 2 or (len(strong_indicators) >= 1 and confidence > 0.8)
        
        return MultiLanguageAnalysisResult(
            is_ai=is_ai,
            confidence=confidence,
            strong_indicators=strong_indicators,
            weak_indicators=weak_indicators,
            reasoning='; '.join(reasoning) if reasoning else "No strong AI indicators found",
            language='csharp'
        )
    
    def _analyze_javascript_file(self, commit_message: str, commit_date: str, file_path: str, file_content: str = None) -> MultiLanguageAnalysisResult:
        """Analyze JavaScript/React file for AI indicators"""
        
        strong_indicators = []
        weak_indicators = []
        reasoning = []
        
        # 1. Check for explicit AI mentions
        for pattern in self.common_ai_patterns['explicit_ai_mention']:
            if re.search(pattern, commit_message, re.IGNORECASE):
                strong_indicators.append("explicit_ai_mention")
                reasoning.append(f"Commit message explicitly mentions AI: '{pattern}'")
        
        # 2. Analyze file content if available
        if file_content:
            content_analysis = self._analyze_javascript_content(file_content)
            strong_indicators.extend(content_analysis['strong'])
            weak_indicators.extend(content_analysis['weak'])
            reasoning.extend(content_analysis['reasoning'])
        
        # 3. Check commit message patterns
        message_analysis = self._analyze_commit_message(commit_message)
        strong_indicators.extend(message_analysis['strong'])
        weak_indicators.extend(message_analysis['weak'])
        reasoning.extend(message_analysis['reasoning'])
        
        # 4. Calculate confidence
        confidence = self._calculate_confidence(strong_indicators, weak_indicators)
        
        # 5. Conservative threshold
        is_ai = len(strong_indicators) >= 2 or (len(strong_indicators) >= 1 and confidence > 0.8)
        
        return MultiLanguageAnalysisResult(
            is_ai=is_ai,
            confidence=confidence,
            strong_indicators=strong_indicators,
            weak_indicators=weak_indicators,
            reasoning='; '.join(reasoning) if reasoning else "No strong AI indicators found",
            language='javascript'
        )
    
    def _analyze_csharp_content(self, content: str) -> Dict[str, List[str]]:
        """Analyze C# content for AI indicators"""
        strong_indicators = []
        weak_indicators = []
        reasoning = []
        
        lines = content.split('\n')
        
        # Check for excessive XML documentation
        xml_doc_count = len(re.findall(r'///\s*<[^>]+>', content))
        method_count = len(re.findall(r'\b(public|private|protected|internal)\s+\w+\s+\w+\s*\(', content))
        
        if method_count > 0 and xml_doc_count / method_count > 0.9:
            strong_indicators.append("excessive_xml_documentation")
            reasoning.append(f"High XML documentation ratio: {xml_doc_count}/{method_count} methods documented")
        
        # Check for perfect formatting
        formatting_score = self._calculate_formatting_perfection(content)
        if formatting_score > 0.99 and len(lines) > 20:
            strong_indicators.append("perfect_formatting")
            reasoning.append(f"Near-perfect formatting consistency: {formatting_score:.2f}")
        
        # Check for over-engineering patterns
        over_engineering_score = self._calculate_csharp_over_engineering(content)
        if over_engineering_score > 0.7:
            strong_indicators.append("over_engineering")
            reasoning.append(f"High over-engineering score: {over_engineering_score:.2f}")
        
        # Check for excessive async usage
        async_methods = len(re.findall(r'\basync\s+\w+\s+\w+\s*\(', content))
        total_methods = len(re.findall(r'\b(public|private|protected|internal)\s+\w+\s+\w+\s*\(', content))
        
        if total_methods > 0 and async_methods / total_methods > 0.8:
            strong_indicators.append("excessive_async_usage")
            reasoning.append(f"High async method ratio: {async_methods}/{total_methods}")
        
        # Check for complex LINQ chains
        complex_linq_chains = len(re.findall(r'\.Where\([^)]*\)\.Select\([^)]*\)\.ToList\(\)', content))
        if complex_linq_chains > 3:
            strong_indicators.append("complex_linq_chains")
            reasoning.append(f"Multiple complex LINQ chains: {complex_linq_chains}")
        
        # Weak indicators
        if len(re.findall(r'\basync\b', content)) > 0:
            weak_indicators.append("async_usage")
        
        if len(re.findall(r'\.Where\(', content)) > 0:
            weak_indicators.append("linq_usage")
        
        if len(re.findall(r'AddScoped|AddTransient|AddSingleton', content)) > 0:
            weak_indicators.append("dependency_injection")
        
        return {
            'strong': strong_indicators,
            'weak': weak_indicators,
            'reasoning': reasoning
        }
    
    def _analyze_javascript_content(self, content: str) -> Dict[str, List[str]]:
        """Analyze JavaScript/React content for AI indicators"""
        strong_indicators = []
        weak_indicators = []
        reasoning = []
        
        lines = content.split('\n')
        
        # Check for excessive JSDoc documentation
        jsdoc_count = len(re.findall(r'/\*\*[\s\S]*?\*/', content))
        function_count = len(re.findall(r'(function\s+\w+|const\s+\w+\s*=\s*\([^)]*\)\s*=>|const\s+\w+\s*=\s*function)', content))
        
        if function_count > 0 and jsdoc_count / function_count > 0.8:
            strong_indicators.append("excessive_jsdoc_documentation")
            reasoning.append(f"High JSDoc documentation ratio: {jsdoc_count}/{function_count} functions documented")
        
        # Check for perfect formatting
        formatting_score = self._calculate_formatting_perfection(content)
        if formatting_score > 0.99 and len(lines) > 20:
            strong_indicators.append("perfect_formatting")
            reasoning.append(f"Near-perfect formatting consistency: {formatting_score:.2f}")
        
        # Check for excessive React hooks usage
        hook_count = len(re.findall(r'\b(useState|useEffect|useCallback|useMemo|useRef)\s*\(', content))
        if hook_count > 10:
            strong_indicators.append("excessive_hooks_usage")
            reasoning.append(f"Many React hooks used: {hook_count}")
        
        # Check for over-engineering patterns
        over_engineering_score = self._calculate_javascript_over_engineering(content)
        if over_engineering_score > 0.7:
            strong_indicators.append("over_engineering")
            reasoning.append(f"High over-engineering score: {over_engineering_score:.2f}")
        
        # Check for complex functional programming patterns
        complex_fp_patterns = len(re.findall(r'\.map\s*\([^)]*\)\.filter\s*\([^)]*\)\.reduce\s*\([^)]*\)', content))
        if complex_fp_patterns > 2:
            strong_indicators.append("complex_functional_patterns")
            reasoning.append(f"Multiple complex functional patterns: {complex_fp_patterns}")
        
        # Weak indicators
        if len(re.findall(r'\buseState\b', content)) > 0:
            weak_indicators.append("react_hooks")
        
        if len(re.findall(r'const\s+\w+\s*=\s*\([^)]*\)\s*=>', content)) > 0:
            weak_indicators.append("arrow_functions")
        
        if len(re.findall(r'\.map\s*\(', content)) > 0:
            weak_indicators.append("functional_programming")
        
        return {
            'strong': strong_indicators,
            'weak': weak_indicators,
            'reasoning': reasoning
        }
    
    def _analyze_commit_message(self, message: str) -> Dict[str, List[str]]:
        """Analyze commit message for AI indicators"""
        strong_indicators = []
        weak_indicators = []
        reasoning = []
        
        message_lower = message.lower()
        
        # Check for explicit AI mentions
        explicit_ai_words = ['cursor', 'copilot', 'ai', 'generated', 'assistant']
        for word in explicit_ai_words:
            if word in message_lower:
                strong_indicators.append(f"explicit_ai_word: {word}")
                reasoning.append(f"Commit message contains AI-related word: '{word}'")
        
        # Check for overly descriptive commit messages
        if len(message.split()) > 20:
            strong_indicators.append("overly_descriptive_message")
            reasoning.append(f"Very long commit message: {len(message.split())} words")
        
        # Check for perfect grammar and formatting
        if self._is_perfectly_formatted_message(message) and len(message.split()) > 15:
            strong_indicators.append("perfect_message_formatting")
            reasoning.append("Commit message has perfect formatting and grammar")
        
        # Weak indicators
        common_words = ['fix', 'update', 'implement', 'add', 'modify', 'improve']
        for word in common_words:
            if word in message_lower:
                weak_indicators.append(f"common_word: {word}")
        
        return {
            'strong': strong_indicators,
            'weak': weak_indicators,
            'reasoning': reasoning
        }
    
    def _analyze_generic_file(self, commit_message: str, commit_date: str, file_path: str, file_content: str = None) -> MultiLanguageAnalysisResult:
        """Generic analysis for unknown file types"""
        
        strong_indicators = []
        weak_indicators = []
        reasoning = []
        
        # Only check for explicit AI mentions in commit message
        for pattern in self.common_ai_patterns['explicit_ai_mention']:
            if re.search(pattern, commit_message, re.IGNORECASE):
                strong_indicators.append("explicit_ai_mention")
                reasoning.append(f"Commit message explicitly mentions AI: '{pattern}'")
        
        confidence = self._calculate_confidence(strong_indicators, weak_indicators)
        is_ai = len(strong_indicators) >= 1
        
        return MultiLanguageAnalysisResult(
            is_ai=is_ai,
            confidence=confidence,
            strong_indicators=strong_indicators,
            weak_indicators=weak_indicators,
            reasoning='; '.join(reasoning) if reasoning else "No strong AI indicators found",
            language='unknown'
        )
    
    def _calculate_formatting_perfection(self, content: str) -> float:
        """Calculate formatting perfection score"""
        lines = content.split('\n')
        if not lines:
            return 0.0
        
        perfect_lines = 0
        total_lines = 0
        
        for line in lines:
            if line.strip():
                total_lines += 1
                
                # Check for perfect indentation (multiples of 4)
                indent = len(line) - len(line.lstrip())
                if indent % 4 == 0:
                    perfect_lines += 1
                
                # Check for consistent spacing around operators
                if re.match(r'^\s*\w+\s*=\s*\w+;?\s*$', line):
                    perfect_lines += 1
                
                # Check for consistent method/function formatting
                if re.match(r'^\s{4}\w+\s+\w+\s*\([^)]*\)\s*\{?\s*$', line):
                    perfect_lines += 1
        
        perfection_ratio = perfect_lines / max(total_lines, 1)
        
        if total_lines < 10:
            return 0.0
        
        return perfection_ratio
    
    def _calculate_csharp_over_engineering(self, content: str) -> float:
        """Calculate C# over-engineering score"""
        score = 0.0
        
        # Interface to implementation ratio
        interfaces = len(re.findall(r'\binterface\s+\w+', content))
        classes = len(re.findall(r'\bclass\s+\w+', content))
        
        if classes > 0:
            interface_ratio = interfaces / classes
            score += min(interface_ratio * 0.3, 0.3)
        
        # Dependency injection usage
        di_usage = len(re.findall(r'(AddScoped|AddTransient|AddSingleton)', content))
        score += min(di_usage * 0.05, 0.2)
        
        # Validation attributes
        validation_attrs = len(re.findall(r'\[(Required|StringLength|Range|EmailAddress|Phone|Url)\]', content))
        score += min(validation_attrs * 0.02, 0.2)
        
        # Repository pattern usage
        repo_patterns = len(re.findall(r'(IRepository|Repository|IUnitOfWork)', content))
        score += min(repo_patterns * 0.1, 0.3)
        
        return min(score, 1.0)
    
    def _calculate_javascript_over_engineering(self, content: str) -> float:
        """Calculate JavaScript over-engineering score"""
        score = 0.0
        
        # React hooks usage
        hooks = len(re.findall(r'\b(useState|useEffect|useCallback|useMemo|useRef)\s*\(', content))
        score += min(hooks * 0.1, 0.3)
        
        # Functional programming patterns
        fp_patterns = len(re.findall(r'\.map\s*\([^)]*\)\.filter\s*\([^)]*\)', content))
        score += min(fp_patterns * 0.1, 0.2)
        
        # Arrow functions
        arrow_functions = len(re.findall(r'const\s+\w+\s*=\s*\([^)]*\)\s*=>', content))
        score += min(arrow_functions * 0.05, 0.2)
        
        # Destructuring
        destructuring = len(re.findall(r'const\s+\{\s*\w+\s*\}\s*=\s*\w+', content))
        score += min(destructuring * 0.05, 0.2)
        
        return min(score, 1.0)
    
    def _is_perfectly_formatted_message(self, message: str) -> bool:
        """Check if commit message has perfect formatting"""
        # Check for proper capitalization
        sentences = message.split('. ')
        if len(sentences) > 1:
            for sentence in sentences[:-1]:
                if sentence and not sentence[0].isupper():
                    return False
        
        # Check for consistent punctuation
        if message.count('.') > 0 and not message.endswith('.'):
            return False
        
        # Check for no extra spaces
        if '  ' in message:
            return False
        
        return True
    
    def _calculate_confidence(self, strong_indicators: List[str], weak_indicators: List[str]) -> float:
        """Calculate confidence based on indicators"""
        base_confidence = 0.0
        
        # Strong indicators have high weight
        for indicator in strong_indicators:
            if 'explicit_ai' in indicator:
                base_confidence += 0.4
            elif 'excessive' in indicator:
                base_confidence += 0.3
            elif 'perfect' in indicator:
                base_confidence += 0.2
            else:
                base_confidence += 0.15
        
        # Weak indicators have low weight
        for indicator in weak_indicators:
            base_confidence += 0.05
        
        return min(base_confidence, 1.0)

# Usage function
def detect_ai_multi_language(commit_message: str, commit_date: str, file_path: str, file_content: str = None) -> Tuple[bool, float, str, str]:
    """Multi-language AI detection function"""
    detector = MultiLanguageAIDetector()
    result = detector.analyze_file(commit_message, commit_date, file_path, file_content)
    
    return result.is_ai, result.confidence, result.reasoning, result.language 